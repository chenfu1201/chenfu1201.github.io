<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基本数据类型</title>
    <url>/2020/05/08/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li>认识二进制</li>
<li>数字的基本数据类型</li>
<li>布尔和字符数据类型</li>
<li>使用各种基本数据类型</li>
</ul>
<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>每一位都是0和1这两个值，到2进位，十就是1010。</p>
<h1 id="bit-和-byte"><a href="#bit-和-byte" class="headerlink" title="bit 和 byte"></a>bit 和 byte</h1><ul>
<li>一个二进制的位叫做一个 bit。网络带宽中的单位，都是bit。</li>
<li>八个二进制的位，组成一个 byte。硬盘等存储的单位，都是byte。</li>
<li>byte 是计算机中基本的衡量存储的单位，计算机在对外使用时不会用 bit 作为划分存储的单位。</li>
</ul>
<h1 id="数字的基本类型"><a href="#数字的基本类型" class="headerlink" title="数字的基本类型"></a>数字的基本类型</h1><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><ul>
<li>byte 占用1个 byte，值域是 -128~127</li>
<li>short 占用2个 byte，值域是 -32768~32767</li>
<li>int 占用4个 byte，值域是 -2147483648~2147483647。 Java 中整数缺省是 int 类型。</li>
<li>long 占用8个 byte，值域是 -9223372036854775808~9223372036854775807</li>
</ul>
<h2 id="浮点（小数）类型"><a href="#浮点（小数）类型" class="headerlink" title="浮点（小数）类型"></a>浮点（小数）类型</h2><ul>
<li>float 占用4个 byte，有精度</li>
<li>double 精度是 float 的两倍，占用8个 byte，Java 中浮点数缺省是 double 类型。</li>
</ul>
<h1 id="布尔和字符数据类型"><a href="#布尔和字符数据类型" class="headerlink" title="布尔和字符数据类型"></a>布尔和字符数据类型</h1><ul>
<li>boolean 占用1个 byte，值域是 true，false。</li>
<li>char 占用2个 byte，值域是所有字符。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Jwt</title>
    <url>/2020/05/14/J2EE/jwt/</url>
    <content><![CDATA[<blockquote>
<p>收藏一篇好文 <a href="https://www.jianshu.com/p/9f5b09b3739a" target="_blank" rel="noopener">SpringBoot 中使用 JWT</a></p>
</blockquote>
<h1 id="JWT-生成登录凭证案例【token】"><a href="#JWT-生成登录凭证案例【token】" class="headerlink" title="JWT 生成登录凭证案例【token】"></a>JWT 生成登录凭证案例【token】</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&lt;!-- jwt --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.9</span>.<span class="number">1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="jwt配置"><a href="#jwt配置" class="headerlink" title="jwt配置"></a>jwt配置</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">chenfu:</span><br><span class="line">  audience:</span><br><span class="line">    <span class="comment"># 密钥, 经过Base64加密, 可自行替换</span></span><br><span class="line">    base64Secret: MDk4ZjZiY2Q0NjIxZDM3M2NhZGU0ZTgzMjYyN2I0ZjY=</span><br><span class="line">    <span class="comment"># JWT的签发主体，存入issuer</span></span><br><span class="line">    name: chenfu</span><br><span class="line">    <span class="comment"># 过期时间，时间戳</span></span><br><span class="line">    expiresSecond: <span class="number">60</span></span><br></pre></td></tr></table></figure>

<h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"chenfu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudienceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Audience audience = <span class="keyword">new</span> Audience();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String base64Secret;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> expiresSecond;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="token-的签发和获取过期时间"><a href="#token-的签发和获取过期时间" class="headerlink" title="token 的签发和获取过期时间"></a>token 的签发和获取过期时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AudienceConfig audienceConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    签发 token</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">(String sub)</span> </span>&#123;</span><br><span class="line">        AudienceConfig.Audience configAudience = audienceConfig.getAudience();</span><br><span class="line">        Key key = <span class="keyword">new</span> SecretKeySpec(DatatypeConverter.parseBase64Binary(configAudience.getBase64Secret()), SignatureAlgorithm.HS512.getJcaName());</span><br><span class="line">        String token = Jwts.builder()</span><br><span class="line">                .setSubject(sub)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, key)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis() + configAudience.getExpiresSecond() * <span class="number">1000</span>))</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    获取过期时间，注意如果已经过期会抛过期异常 </span></span><br><span class="line"><span class="comment">//    io.jsonwebtoken.ExpiredJwtException.class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSubject</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        AudienceConfig.Audience configAudience = audienceConfig.getAudience();</span><br><span class="line">        Key key = <span class="keyword">new</span> SecretKeySpec(DatatypeConverter.parseBase64Binary(configAudience.getBase64Secret()), SignatureAlgorithm.HS512.getJcaName());</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(key)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody()</span><br><span class="line">                .getSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>Jwt</tag>
        <tag>SpringBoot2.x 中使用 Jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2019/08/03/Java%E5%9F%BA%E7%A1%80/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>Java虚拟机的大部分操作都不需要特别关注，关键性的问题在于运行时数据区的结构组成上，我们平常进行堆栈分析都是这个区内。</p>
</blockquote>
<a id="more"></a>

<h2 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h2><p>JVM中运行时数据区包括五个部分：</p>
<ul>
<li>程序计数器【寄存器】</li>
<li>Java栈【运行时的单位】</li>
<li>Java堆【存储的单元】</li>
<li>方法区</li>
<li>本地方法栈</li>
</ul>
<h3 id="运行时数据区模型图"><a href="#运行时数据区模型图" class="headerlink" title="运行时数据区模型图"></a>运行时数据区模型图</h3><p><img src="https://img-blog.csdnimg.cn/2019042521325463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意：不同的JDK版本，ClassLoader是有所不同的。</p>
<h3 id="运行时数据区各个区域的作用"><a href="#运行时数据区各个区域的作用" class="headerlink" title="运行时数据区各个区域的作用"></a>运行时数据区各个区域的作用</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>作用如下：</p>
<ul>
<li>用来指示执行哪条指令，是一块很小的内存区域，小到可以忽略不记。</li>
<li>在程序编译时会为字节码的每一行的都分配一个程序计数器。</li>
<li>多线程并行执行时，每一个线程对象都会有自己独立的程序计数器，以保证CPU切换后可以取得当前程序的执行位置。</li>
<li>JVM中规定，如果当前线程执行的是非native方法，程序计数器保存的是当前需要执行的指令的地址，如果线程执行的是native方法，程序计数器保存的值是undefined。</li>
</ul>
<p>因为程序计数器中存储的数据所占的空间大小不会随着程序的执行而发生变化，因此，程序计数器不会发生内存溢出现象【OOM】。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>虚拟机栈描述的是Java方法执行的内存模型。执行一个方法时会产生一个栈帧，随后将其保存到栈【先进后出】的顶部，方法执行完毕后会自动将此栈帧进行出栈。顶部的栈帧就表示的当前执行的方法。</p>
<ul>
<li>栈结构分为栈顶和栈底，遵循先进后出的（FILO）的规则。</li>
<li>栈内存是线程私有的，其生命周期和线程相同。</li>
</ul>
<p>注意 ：</p>
<ol>
<li>如果当前请求的栈的深度【栈帧数量过多】过大，虚拟机可能会抛出 StackOverflowError 异常。 【反映在代码上就是出现了死循环，递归没有结束】</li>
<li>不同的虚拟机实现不同，有的虚拟机允许栈动态扩展，当内存不足以扩展栈的时候，会抛出OutOfMemoryError异常。</li>
</ol>
<p>上面已经说过了栈的基本单位是栈帧，那么接下来再来看一下栈帧的结构</p>
<h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><p>栈帧主要由以下部分组成</p>
<ol>
<li>局部变量表<br>方法的局部变量和形参，以变量槽【solt】为基本单位，只允许保存32位长度的变量，如果超过32位长度则会开辟两个连续的solt【64位长度，long和double】。</li>
<li>操作数栈<br>表达式的计算是在栈中完成的。</li>
<li>方法返回地址<br>方法执行完毕后需要返回调用此方法的位置，所以需要在栈帧中保存方法返回地址。</li>
<li>指向当前方法所属的类的运行时常量池的引用<br>引用其他类的常量或使用String池中的字符串。</li>
</ol>
<h5 id="栈和栈帧模型图"><a href="#栈和栈帧模型图" class="headerlink" title="栈和栈帧模型图"></a>栈和栈帧模型图</h5><p><img src="https://img-blog.csdnimg.cn/20190622162221445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是JVM中非常重要的一块内存区域，一般而言，在方法区很少执行垃圾回收。</p>
<ul>
<li>该区域所有线程对象共享。</li>
<li>该区域保存了每一个类的信息【类名称、方法信息、成员信息、接口信息、静态变量、常量和常量池等】。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与Java栈内存的功能类似，唯一的区别是本地方法栈是为本地方法服务的。</p>
<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><p>此区域所有线程对象共享！堆内存主要保存具体的数据信息【对象】，在JVM启动时将被自动创建。Java开发人员无需管理此区域的空间释放，其会由Java垃圾收集器自动释放，此空间是垃圾收集器的主要管理区域。该区域又细分如下几个区域。</p>
<ul>
<li>年轻代：所有新创建的对象都保存在年轻代里面。</li>
<li>老年代：所有常用的对象【多次清理之后还被保留的对象】，新建的超大对象【将会占用大量内存的对象】。</li>
<li>元空间：JDK1.8之后，新增了元空间的概念，元空间的本质描述的就是直接内存。【在JDK1.8以前，是没有元空间的，对应的内存被称为“永久代”（方法区：方法区的内容无法回收）】</li>
<li>伸缩区：当模块内存空间不足时，会释放伸缩区中的内存空间，进行更多对象的存储，所以伸缩区是一块可以被不断修改大小的内存区域，<strong>所有的内存代都有此区域</strong>。</li>
</ul>
<h5 id="堆内存模型图"><a href="#堆内存模型图" class="headerlink" title="堆内存模型图"></a>堆内存模型图</h5><p><img src="https://img-blog.csdnimg.cn/20190624103658112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="年轻代内存划分"><a href="#年轻代内存划分" class="headerlink" title="年轻代内存划分"></a>年轻代内存划分</h5><p>年轻代分为两个部分：伊甸园区、存活区（存活区都会为其分为两块大小相同的内存区域），年轻代的内存分配如下。</p>
<ol>
<li>伊甸园区：新生对象。</li>
<li>存活区：经过垃圾回收后仍存活的对象。</li>
</ol>
<h6 id="年轻代内存模型图"><a href="#年轻代内存模型图" class="headerlink" title="年轻代内存模型图"></a>年轻代内存模型图</h6><p><img src="https://img-blog.csdnimg.cn/20190624121837864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以发现，伊甸园区在整个年轻代中的比重是最大的，而这个比例的关系默认情况下大致为 8：1：1</p>
<h5 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h5><p>上边已经介绍过了，元空间的本质描述的就是直接内存。那么直接内存又是什么呢？<br>所谓的直接内存，指的是虚拟机之外的主机内存【假设，我的服务器有8G内存，其中2G内存给了JVM，剩下的6G就是直接内存】。直接内存并不会受到JVM的控制，但在JDK中提供有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，这种方式会将native函数库分配在直接内存，并且会通过存储在JVM堆内存中的“DirectByteBuffer”来引用它。由于直接内存会受到本机系统内存的限制，所以也有可能出现“OOM”错误。</p>
<p><strong>正因为直接内存的存在，所以我们断然不能把服务器的所有内存都分配给JVM。</strong></p>
<h3 id="OOM【OutOfMemoryError】总结"><a href="#OOM【OutOfMemoryError】总结" class="headerlink" title="OOM【OutOfMemoryError】总结"></a>OOM【OutOfMemoryError】总结</h3><p>在进行多线程开发访问的过程里面，所有的线程一定可以共享某一个线程执行体的堆内存空间（这个堆内存空间可以使用Runnable或者是Callable进行表述），同时方法上也可以实现线程操作的共享，正是因为方法上可以共享，所以在进行同步的时候往往就要在方法里面追加同步锁等相关定义。如果要进行内存区域的理解，那么首先就必须考虑程序代码之中可能出现的<strong>OOM</strong>问题。OOM分为两种情况：栈内存溢出【Stackoverflow】、堆内存溢出。<br><img src="https://img-blog.csdnimg.cn/20190622154807404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从开发角度来讲，最为常见的OOM肯定是堆内存溢出（产生了大量无用对象），栈内存发生数据溢出主要出现在<strong>递归操作</strong>上。正是因为所有的递归操作在执行的时候有可能产生栈溢出的问题，所以在项目编写之中往往都会建议使用while循环来代替递归操作。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2000/03/13/Java%E5%9F%BA%E7%A1%80/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>索引</title>
    <url>/2020/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引?"></a>什么是索引?</h1><blockquote>
<p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。在 MySQL 中，索引是在存储引擎层实现的</p>
</blockquote>
<h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。因为InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<blockquote>
<p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p>
</blockquote>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</li>
</ul>
<blockquote>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p>
</blockquote>
<h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>在非主键索引树上查到主键数据，回到主键索引树搜索的过程，我们称为回表</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果某个非主键索引中的数据，已经满足了我们的查询需求，因此可以直接提供查询结果，不需要回表。</p>
<blockquote>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
</blockquote>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><blockquote>
<p>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p>
</blockquote>
<p>建立联合索引的原则</p>
<ul>
<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>
</ul>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><blockquote>
<p>在 MySQL 5.6引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2020/04/25/Redis/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="分布式锁能解决什么问题？"><a href="#分布式锁能解决什么问题？" class="headerlink" title="分布式锁能解决什么问题？"></a>分布式锁能解决什么问题？</h1><p>分布式应用进行逻辑处理时经常会遇到并发问题。比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。（Wiki 解释：所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 线程切换。） 这个时候就要使用到分布式锁来限制程序的并发执行。Redis 分布式锁使用非常广泛。</p>
<h1 id="细说分布式锁"><a href="#细说分布式锁" class="headerlink" title="细说分布式锁"></a>细说分布式锁</h1><p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“位置”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p>
<blockquote>
<p>占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放。</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; setnx lock true</span><br><span class="line">OK</span><br><span class="line">... 业务操作 ...</span><br><span class="line">&gt; del lock</span><br></pre></td></tr></table></figure>

<p>上述逻辑乍一看似乎是没什么问题，但其中其实隐藏着一个很大的问题。试想用 Java 实现上述逻辑，假设在业务操作部分出现了一个异常，最终导致没有执行 del 的操作，那么就会造成死锁，锁永远得不到释放，最终导致业务的无法使用。</p>
<h2 id="如何避免分布式死锁"><a href="#如何避免分布式死锁" class="headerlink" title="如何避免分布式死锁"></a>如何避免分布式死锁</h2><p>我们在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; setnx lock true</span><br><span class="line">OK</span><br><span class="line">&gt; expire lock <span class="number">5</span></span><br><span class="line">... 业务操作 ...</span><br><span class="line">&gt; del lock</span><br></pre></td></tr></table></figure>

<p>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>
<blockquote>
<p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。事务里没有 if else 分支逻辑，事务的特点是一口气执行，要么全部执行要么一个都不执行。 </p>
</blockquote>
<p>为了解决上述疑难，Redis 开源社区涌现了一堆分布式锁的 library，专门用来解决这个问题。实现方法极为复杂，小白用户一般要费很大的精力才可以搞懂。如果你需要使用分布式锁，意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。</p>
<h3 id="分布式死锁的终极解决方案"><a href="#分布式死锁的终极解决方案" class="headerlink" title="分布式死锁的终极解决方案"></a>分布式死锁的终极解决方案</h3><p>为了治理上述乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 setnx 和 expire 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁 library 可以休息了。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; set lock true ex <span class="number">5</span> nx</span><br><span class="line">OK</span><br><span class="line">... 业务操作 ...</span><br><span class="line">&gt; del lock</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。 </p>
</blockquote>
<h2 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h2><p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。</p>
<blockquote>
<p>假设第一个线程执行的时候锁过期了，第二个线程重新持有了这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻辑执行完之前拿到了锁。 </p>
</blockquote>
<h3 id="超时问题解决方案"><a href="#超时问题解决方案" class="headerlink" title="超时问题解决方案"></a>超时问题解决方案</h3><p>为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决。 </p>
<p>还有一个更加安全的方案是将 set 指令的 value 设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key。但是匹配 value 和删除 key 不是一个原子操作，Redis 也没有提供类似于 delifequals 这样的指令，这就需要使用 Lua 脚本来处理了，因为 Lua 脚本可以保证连续多个指令的原子性执行。 </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis 分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基础命令</title>
    <url>/2020/04/19/Redis/Redis-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Redis 基础数据结构 常用的命令。</p>
<h1 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h1><h2 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;set s1 v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;get s1</span><br><span class="line">v1</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;exists s1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;del s1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;get s1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h2 id="批量键值对"><a href="#批量键值对" class="headerlink" title="批量键值对"></a>批量键值对</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;set s1 v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;set s2 v2</span><br><span class="line">OK</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;mget s1 s2 s3</span><br><span class="line"><span class="number">1</span>) v1</span><br><span class="line"><span class="number">2</span>) v2</span><br><span class="line"><span class="number">3</span>) (nil)</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;mset s3 v3 s4 v4 s5 unknown</span><br><span class="line">OK</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;mget s3 s4 s5</span><br><span class="line"><span class="number">1</span>) v3</span><br><span class="line"><span class="number">2</span>) v4</span><br><span class="line"><span class="number">3</span>) unknown</span><br></pre></td></tr></table></figure>

<h2 id="过期和-set-命令扩展"><a href="#过期和-set-命令扩展" class="headerlink" title="过期和 set 命令扩展"></a>过期和 set 命令扩展</h2><p>可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的失效时间。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;set s6 v6</span><br><span class="line">OK</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;get s6</span><br><span class="line">v6</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;expire s6 <span class="number">5</span> 【<span class="number">5</span>秒 后过期】</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;get s6</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;setex s6 <span class="number">6</span> hello 【<span class="number">6</span>秒 后过期，等价于 set+expire】</span><br><span class="line">OK</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;get s6</span><br><span class="line">hello</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;get s6</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;setnx s6 v6 【如果 s6 不存在就执行 set 创建 】</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;get s6</span><br><span class="line">v6</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;setnx s6 v7 【因为 s6 已经存在，所以set 创建不成功 】</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;get s6 【s6 的值没有变化】</span><br><span class="line">v6</span><br></pre></td></tr></table></figure>

<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值，Redis 会报错。 </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;set s1_age <span class="number">30</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;incr s1_age</span><br><span class="line">(integer) <span class="number">31</span></span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;incrby s1_age <span class="number">5</span></span><br><span class="line">(integer) <span class="number">36</span></span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;incrby s1_age <span class="literal">-5</span></span><br><span class="line">(integer) <span class="number">31</span></span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;set s_max <span class="number">9223372036854775807</span> 【Long.Max】</span><br><span class="line">OK</span><br><span class="line"><span class="number">172.19</span>.<span class="number">190.187</span>:<span class="number">6379</span>&gt;incr s_max</span><br><span class="line">ERR increment or decrement would overflow</span><br></pre></td></tr></table></figure>

<h1 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush java spring mvc</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; llen java</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop java</span><br><span class="line"><span class="string">"spring"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop java</span><br><span class="line"><span class="string">"mvc"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop java</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush java spring <span class="keyword">data</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpop java</span><br><span class="line"><span class="string">"data"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpop java</span><br><span class="line"><span class="string">"spring"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpop java</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush java spring mvc <span class="keyword">data</span> boot</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush java mvc</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lindex java <span class="number">1</span> 【慎用，会对链表进行遍历，参数越大性能越差】</span><br><span class="line"><span class="string">"mvc"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange java <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"spring"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mvc"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"data"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"boot"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"mvc"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ltrim java <span class="number">1</span> <span class="literal">-1</span> 【保留区间之内的元素】</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange java <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"mvc"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"data"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"boot"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"mvc"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ltrim java <span class="number">1</span> <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; llen java</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists java</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<h1 id="hash（字典）"><a href="#hash（字典）" class="headerlink" title="hash（字典）"></a>hash（字典）</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset books java <span class="string">"think in java"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset books spring <span class="string">"beanFactory"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset books go <span class="string">"hello go"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset books python <span class="string">"python"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hgetall books</span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"think in java"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"spring"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"beanFactory"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"go"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"hello go"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"python"</span></span><br><span class="line"><span class="number">8</span>) <span class="string">"python"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hget books java</span><br><span class="line"><span class="string">"think in java"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset books spring <span class="string">'IOC and AOP'</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hget books spring</span><br><span class="line"><span class="string">"IOC and AOP"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hmset books java <span class="string">'hello java'</span> python <span class="string">'hello python'</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hgetall books</span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"hello java"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"spring"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"IOC and AOP"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"go"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"hello go"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"python"</span></span><br><span class="line"><span class="number">8</span>) <span class="string">"hello python"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hincrby user<span class="literal">-h</span> age <span class="number">10</span></span><br><span class="line">(integer) <span class="number">10</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hget user<span class="literal">-h</span> age</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<h1 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd award chenfu1 chenfu2 chenfu1</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd award chenfu2 【重复元素】</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd award chenfu3</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers award 【显示的是插入顺序不一致，因为set是无序的】</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu3"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sismembers award chenfu2 【查询某个value是否存在】</span><br><span class="line">(error) ERR unknown command <span class="string">'sismembers'</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sismember award chenfu2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sismember award chenfu5</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scard award 【获取set 集合长度】</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers award</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu3"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers award</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu3"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd award chenfu8</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd award chenfu6</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers award</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu3"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"chenfu8"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"chenfu6"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd award chenfu0</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers award</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu8"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"chenfu3"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"chenfu6"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"chenfu0"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd award java1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers award</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu8"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu3"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"java1"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"chenfu6"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"chenfu0"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; spop award 【弹出一个元素，随机弹的】</span><br><span class="line"><span class="string">"chenfu8"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; spop award</span><br><span class="line"><span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<h1 id="zset（有序列表）"><a href="#zset（有序列表）" class="headerlink" title="zset（有序列表）"></a>zset（有序列表）</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd zuser <span class="number">10</span> <span class="string">'chenfu10'</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd zuser <span class="number">1</span> <span class="string">'chenfu1'</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd zuser <span class="number">2</span> <span class="string">'chenfu2'</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange zuser <span class="number">0</span> <span class="literal">-1</span> 【按score 排序，参数区间是排名范围|score】</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu10"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrange zuser <span class="number">0</span> <span class="literal">-1</span> 【按score 逆序列出】</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu10"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcard zuser 【统计元素个数】</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zscore zuser <span class="string">'chenfu2'</span> 【获取指定元素score】</span><br><span class="line"><span class="string">"2"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrank zuser <span class="string">'chenfu2'</span> 【获取指定元素的排名】</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrank zuser <span class="string">'chenfu1'</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrank zuser <span class="string">'chenfu0'</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrangebyscore zuser <span class="literal">-inf</span> <span class="number">2</span> [<span class="type">withscores</span>] 【根据分值区间遍历zset，withscores是否返回分值，inf：无穷大的意思】</span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"chenfu2"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrem zuser <span class="string">'chenfu2'</span> 【删除元素】</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange zuser <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"chenfu1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"chenfu10"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis 基础命令</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2018/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><blockquote>
<p>事务是对数据库的一系列操作，有明确的开始和结束标志，且要被完全执行，要么全部成功，要么全部失败。</p>
</blockquote>
<h1 id="为什么要使用事务？"><a href="#为什么要使用事务？" class="headerlink" title="为什么要使用事务？"></a>为什么要使用事务？</h1><blockquote>
<p>为了保证我们业务的完整性，因为我们的业务就是一个序列操作，具备这种要么全部成功，要么全部失败的特性。</p>
</blockquote>
<h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><p>事务具备如下四大特征【ACID】</p>
<ol>
<li>原子性（Atomicity）<br>事务最终状态只有两种，全部执行成功和全部不执行，事务中任何一项操作失败，都会导致整个事务失败。一旦失败所有操作都会被取消【回滚】，就像事务从来没有执行过一样。</li>
<li>一致性（Consistency）<br>事务执行前后，数据的完整性保持一致。</li>
<li>隔离性（Isolation）<br>多个事务并发执行时，多个事务之间互不干扰。即一个事务内部的操作及使用的数据，对其他并发事务是隔离的。</li>
<li>持久性（Durability）<br>事务结束后，对数据库所作的更改被永久保存下来了，即使发生系统故障或宕机，只要数据库能够恢复到被访问，那么一定能够被恢复到事务完成时的状态。</li>
</ol>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><blockquote>
<p>当数据库上有多个事务同时执行的时候，就可能出现脏读，不可重复读和幻读的问题，因此就有了“隔离级别”的概念。</p>
</blockquote>
<p>首先要知道，隔离得越严实，效率就越低。因此很多时候，要在这二者之间寻求一个平衡点。SQL标准的事务隔离级别包括如下几种。</p>
<ol>
<li>读未提交（read uncommitted）<br>一个事务还没提交，此时它所做的变更能被别的事务看到。此隔离级别会引发 <strong>脏读</strong> 的问题</li>
<li>读提交（read committed）<br>一个事务提交之后，它做的变更才会被其他事务看到。此隔离级别会引发 <strong>不可重复读</strong> 的问题。</li>
<li>可重复读（repeatable read）<br>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。此隔离级别下会引发 <strong>幻读</strong> 的问题。</li>
<li>串行化（serializable）<br>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后序访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ol>
<blockquote>
<p>Oracle数据库的默认隔离级别是 “读提交” 而 MySQL 的默认隔离级别是 “可重复读”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别一致，一定要记得修改隔离级别为“读提交”。</p>
</blockquote>
<h3 id="脏读，不可重复读和幻读都是什么？"><a href="#脏读，不可重复读和幻读都是什么？" class="headerlink" title="脏读，不可重复读和幻读都是什么？"></a>脏读，不可重复读和幻读都是什么？</h3><ol>
<li>脏读<br>脏读就是拿了别的事务还没提交的数据在此基础上做了别的业务处理。</li>
<li>不可重复读<br>在一个事务中，以相同的查询条件检索同一条数据，且当前事务没对此数据做任何修改，结果两次检索出的数据却不一致，说明有别的事务修改了此数据。</li>
<li>幻读<br>在一个事务中，以某个条件检索出了一批数据，假设检索出了五条数据集，批量修改此数据集，预期是返回修改五条记录。结果发现修改了六条，说明有别的事务插入了满足此检索条件的数据集。</li>
</ol>
<blockquote>
<p>这里对幻读的描述只是其中的一个场景，实际上不同事物 update，insert，delete 到同一批数据，都会出现幻读。原因在于“这些操作都是当前读的”。</p>
</blockquote>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><blockquote>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
</blockquote>
<p><strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong></p>
<ol>
<li>“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>
<li>“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是。</li>
<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。</li>
<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li>
</ol>
<h3 id="福利来啦"><a href="#福利来啦" class="headerlink" title="福利来啦"></a>福利来啦</h3><p>事务这一块的东西非常非常重要，楼主在大四出来实习的时候，基本去哪面试都有被问过，有幸读过一篇阅读量上万的事务总结，非常的受用，可是随着学习的积累，楼主发现那篇文章描述的知识点有一些错误之处【说明了学习时找对学习资源的重要性】，这个错误楼主不止在那篇文章中看到过，在别的地方也见到过，所以在这里做个记录，希望能帮到有缘人。</p>
<ul>
<li>情景再现<br>部分博客对幻读的描述是这样的：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。</li>
</ul>
<p>经楼主查证，其实这种幻读【BUG】，已经被 MVCC 机制修复了。只是比较老的书都已经发版了也没法改，新发行的书中基本都有提到这一点。为了增加说服力，以图做镇，以示清白！<br><img src="https://img-blog.csdnimg.cn/2020011316340260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基础数据结构</title>
    <url>/2020/04/19/Redis/Redis-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Redis-使用场景："><a href="#Redis-使用场景：" class="headerlink" title="Redis 使用场景："></a>Redis 使用场景：</h1><ol>
<li>关系型数据库的缓存存在</li>
<li>可以做任务队列</li>
<li>大量数据运算</li>
<li>排行榜<br>Redis非常擅长做大量数据的排行榜</li>
</ol>
<h1 id="使用-Docker-安装-Redis"><a href="#使用-Docker-安装-Redis" class="headerlink" title="使用 Docker 安装 Redis"></a>使用 Docker 安装 Redis</h1><ol>
<li>拉取 Redis 镜像<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull redis:<span class="number">5.0</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li>创建并启动 Redis 容器<br>[– requirepass 设置密码，如下设置的此容器中 Redis 密码为 “root” ]<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> -<span class="literal">-name</span> redis <span class="literal">-p</span> <span class="number">6379</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="literal">-v</span> <span class="variable">$PWD</span>/conf/redis.conf:/redis.conf \</span><br><span class="line"><span class="literal">-v</span> <span class="variable">$PWD</span>/<span class="keyword">data</span>:/<span class="keyword">data</span> redis:<span class="number">5.0</span>.<span class="number">3</span> \</span><br><span class="line">redis<span class="literal">-server</span> -<span class="literal">-appendonly</span> yes \</span><br><span class="line">-<span class="literal">-requirepass</span> <span class="string">"root"</span></span><br></pre></td></tr></table></figure></li>
<li>使用 Redis 客户端连接容器内的 Redis 实例<br><img src="https://img-blog.csdnimg.cn/20191103115457632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h2 id="Redis-可执行文件介绍"><a href="#Redis-可执行文件介绍" class="headerlink" title="Redis 可执行文件介绍"></a>Redis 可执行文件介绍</h2><p>在 ../redis/bin 下有几个可执行文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis<span class="literal">-benchmark</span>		----性能测试工具</span><br><span class="line">redis<span class="literal">-check</span><span class="literal">-aof</span>		---<span class="literal">-AOF</span>文件修复工具</span><br><span class="line">redis<span class="literal">-check</span><span class="literal">-dump</span>	---<span class="literal">-RDB</span>文件检查工具（快照持久化文件）</span><br><span class="line">redis<span class="literal">-cli</span>			----命令行客户端</span><br><span class="line">redis<span class="literal">-server</span>		---<span class="literal">-redis</span>服务器启动命令</span><br></pre></td></tr></table></figure>

<h2 id="Redis-命令大全"><a href="#Redis-命令大全" class="headerlink" title="Redis 命令大全"></a>Redis 命令大全</h2><p>redis命令大全：<a href="http://doc.redisfans.com/index.html" target="_blank" rel="noopener">redis命令参考</a></p>
<h1 id="Redis-基础数据结构"><a href="#Redis-基础数据结构" class="headerlink" title="Redis 基础数据结构"></a>Redis 基础数据结构</h1><p>Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。</p>
<blockquote>
<p>Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。</p>
</blockquote>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>字符串 string 是 Redis 最简单的数据结构。</p>
<blockquote>
<p>Redis 的字符串是动态字符串，是可以修改的字符串。内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p>
</blockquote>
<p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。</p>
<h2 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h2><p>Redis 的列表相当于 Java 语言里面的 LinkedList，<strong>注意它是链表而不是数组</strong>。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>
<blockquote>
<p>当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。 </p>
</blockquote>
<p>Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理</p>
<h2 id="hash（字典）"><a href="#hash（字典）" class="headerlink" title="hash（字典）"></a>hash（字典）</h2><p>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为  Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。</p>
<blockquote>
<p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 的子指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。 </p>
<blockquote>
<p>当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。<br>同字符串一样，hash 结构中的单个子 key 也可以进行计数，它对应的指令是 hincrby，和 incr 使用基本一样。 </p>
</blockquote>
</blockquote>
<p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p>
<h2 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h2><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>
<blockquote>
<p>当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。</p>
</blockquote>
<p>set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<h2 id="zset-（有序列表）"><a href="#zset-（有序列表）" class="headerlink" title="zset （有序列表）"></a>zset （有序列表）</h2><p>zset 可能是 Redis 提供的最为特色的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部  value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫着「跳跃列表」的数据结构。</p>
<blockquote>
<p>zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。</p>
</blockquote>
<p>zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。 </p>
<h1 id="容器型数据结构的通用规则"><a href="#容器型数据结构的通用规则" class="headerlink" title="容器型数据结构的通用规则"></a>容器型数据结构的通用规则</h1><p>list/hash/set/zset 这四种数据结构是容器型数据结构，他们共享一下两条规则：</p>
<ol>
<li><p>create if not exists<br>如果容器不存在，那就创建一个再进行操作。比如 rpush 操作刚开始没有列表，此时 redis 就会自动创建一个，然后再 rpush 进去。</p>
</li>
<li><p>drop if not elements<br>如果容器内没有元素了，那么立即删除元素，释放内存。</p>
</li>
</ol>
<h1 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h1><ol>
<li><p>Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会删除相应的对象【过期是以对象为单位的，不是以容器内的某个元素为单位的】。</p>
</li>
<li><p>如果一个字符串【容器型的过期时间不受影响】已经设置了过期时间，然后调用了 set 方法修改了它，它的过期时间会消失。</p>
</li>
</ol>
<p>字符串型</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set s s1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire s <span class="number">600</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl s</span><br><span class="line">(integer) <span class="number">596</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set s s2</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl s</span><br><span class="line">(integer) <span class="literal">-1</span></span><br></pre></td></tr></table></figure>
<p>容器型</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset h1 f1 v1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire h1 <span class="number">600</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl h1</span><br><span class="line">(integer) <span class="number">598</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset h1 f2 v2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl h1</span><br><span class="line">(integer) <span class="number">589</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis 基础数据结构</tag>
        <tag>Docker 安装 Redis</tag>
      </tags>
  </entry>
</search>
