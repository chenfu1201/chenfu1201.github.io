<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2000/03/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>索引</title>
    <url>/2020/03/01/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引?"></a>什么是索引?</h1><blockquote>
<p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。在 MySQL 中，索引是在存储引擎层实现的</p>
</blockquote>
<h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。因为InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<blockquote>
<p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p>
</blockquote>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</li>
</ul>
<blockquote>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p>
</blockquote>
<h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>在非主键索引树上查到主键数据，回到主键索引树搜索的过程，我们称为回表</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果某个非主键索引中的数据，已经满足了我们的查询需求，因此可以直接提供查询结果，不需要回表。</p>
<blockquote>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
</blockquote>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><blockquote>
<p>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p>
</blockquote>
<p>建立联合索引的原则</p>
<ul>
<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>
</ul>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><blockquote>
<p>在 MySQL 5.6引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2019/08/03/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>Java虚拟机的大部分操作都不需要特别关注，关键性的问题在于运行时数据区的结构组成上，我们平常进行堆栈分析都是这个区内。</p>
</blockquote>
<a id="more"></a>

<h2 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h2><p>JVM中运行时数据区包括五个部分：</p>
<ul>
<li>程序计数器【寄存器】</li>
<li>Java栈【运行时的单位】</li>
<li>Java堆【存储的单元】</li>
<li>方法区</li>
<li>本地方法栈</li>
</ul>
<h3 id="运行时数据区模型图"><a href="#运行时数据区模型图" class="headerlink" title="运行时数据区模型图"></a>运行时数据区模型图</h3><p><img src="https://img-blog.csdnimg.cn/2019042521325463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意：不同的JDK版本，ClassLoader是有所不同的。</p>
<h3 id="运行时数据区各个区域的作用"><a href="#运行时数据区各个区域的作用" class="headerlink" title="运行时数据区各个区域的作用"></a>运行时数据区各个区域的作用</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>作用如下：</p>
<ul>
<li>用来指示执行哪条指令，是一块很小的内存区域，小到可以忽略不记。</li>
<li>在程序编译时会为字节码的每一行的都分配一个程序计数器。</li>
<li>多线程并行执行时，每一个线程对象都会有自己独立的程序计数器，以保证CPU切换后可以取得当前程序的执行位置。</li>
<li>JVM中规定，如果当前线程执行的是非native方法，程序计数器保存的是当前需要执行的指令的地址，如果线程执行的是native方法，程序计数器保存的值是undefined。</li>
</ul>
<p>因为程序计数器中存储的数据所占的空间大小不会随着程序的执行而发生变化，因此，程序计数器不会发生内存溢出现象【OOM】。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>虚拟机栈描述的是Java方法执行的内存模型。执行一个方法时会产生一个栈帧，随后将其保存到栈【先进后出】的顶部，方法执行完毕后会自动将此栈帧进行出栈。顶部的栈帧就表示的当前执行的方法。</p>
<ul>
<li>栈结构分为栈顶和栈底，遵循先进后出的（FILO）的规则。</li>
<li>栈内存是线程私有的，其生命周期和线程相同。</li>
</ul>
<p>注意 ：</p>
<ol>
<li>如果当前请求的栈的深度【栈帧数量过多】过大，虚拟机可能会抛出 StackOverflowError 异常。 【反映在代码上就是出现了死循环，递归没有结束】</li>
<li>不同的虚拟机实现不同，有的虚拟机允许栈动态扩展，当内存不足以扩展栈的时候，会抛出OutOfMemoryError异常。</li>
</ol>
<p>上面已经说过了栈的基本单位是栈帧，那么接下来再来看一下栈帧的结构</p>
<h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><p>栈帧主要由以下部分组成</p>
<ol>
<li>局部变量表<br>方法的局部变量和形参，以变量槽【solt】为基本单位，只允许保存32位长度的变量，如果超过32位长度则会开辟两个连续的solt【64位长度，long和double】。</li>
<li>操作数栈<br>表达式的计算是在栈中完成的。</li>
<li>方法返回地址<br>方法执行完毕后需要返回调用此方法的位置，所以需要在栈帧中保存方法返回地址。</li>
<li>指向当前方法所属的类的运行时常量池的引用<br>引用其他类的常量或使用String池中的字符串。</li>
</ol>
<h5 id="栈和栈帧模型图"><a href="#栈和栈帧模型图" class="headerlink" title="栈和栈帧模型图"></a>栈和栈帧模型图</h5><p><img src="https://img-blog.csdnimg.cn/20190622162221445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是JVM中非常重要的一块内存区域，一般而言，在方法区很少执行垃圾回收。</p>
<ul>
<li>该区域所有线程对象共享。</li>
<li>该区域保存了每一个类的信息【类名称、方法信息、成员信息、接口信息、静态变量、常量和常量池等】。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与Java栈内存的功能类似，唯一的区别是本地方法栈是为本地方法服务的。</p>
<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><p>此区域所有线程对象共享！堆内存主要保存具体的数据信息【对象】，在JVM启动时将被自动创建。Java开发人员无需管理此区域的空间释放，其会由Java垃圾收集器自动释放，此空间是垃圾收集器的主要管理区域。该区域又细分如下几个区域。</p>
<ul>
<li>年轻代：所有新创建的对象都保存在年轻代里面。</li>
<li>老年代：所有常用的对象【多次清理之后还被保留的对象】，新建的超大对象【将会占用大量内存的对象】。</li>
<li>元空间：JDK1.8之后，新增了元空间的概念，元空间的本质描述的就是直接内存。【在JDK1.8以前，是没有元空间的，对应的内存被称为“永久代”（方法区：方法区的内容无法回收）】</li>
<li>伸缩区：当模块内存空间不足时，会释放伸缩区中的内存空间，进行更多对象的存储，所以伸缩区是一块可以被不断修改大小的内存区域，<strong>所有的内存代都有此区域</strong>。</li>
</ul>
<h5 id="堆内存模型图"><a href="#堆内存模型图" class="headerlink" title="堆内存模型图"></a>堆内存模型图</h5><p><img src="https://img-blog.csdnimg.cn/20190624103658112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="年轻代内存划分"><a href="#年轻代内存划分" class="headerlink" title="年轻代内存划分"></a>年轻代内存划分</h5><p>年轻代分为两个部分：伊甸园区、存活区（存活区都会为其分为两块大小相同的内存区域），年轻代的内存分配如下。</p>
<ol>
<li>伊甸园区：新生对象。</li>
<li>存活区：经过垃圾回收后仍存活的对象。</li>
</ol>
<h6 id="年轻代内存模型图"><a href="#年轻代内存模型图" class="headerlink" title="年轻代内存模型图"></a>年轻代内存模型图</h6><p><img src="https://img-blog.csdnimg.cn/20190624121837864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以发现，伊甸园区在整个年轻代中的比重是最大的，而这个比例的关系默认情况下大致为 8：1：1</p>
<h5 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h5><p>上边已经介绍过了，元空间的本质描述的就是直接内存。那么直接内存又是什么呢？<br>所谓的直接内存，指的是虚拟机之外的主机内存【假设，我的服务器有8G内存，其中2G内存给了JVM，剩下的6G就是直接内存】。直接内存并不会受到JVM的控制，但在JDK中提供有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，这种方式会将native函数库分配在直接内存，并且会通过存储在JVM堆内存中的“DirectByteBuffer”来引用它。由于直接内存会受到本机系统内存的限制，所以也有可能出现“OOM”错误。</p>
<p><strong>正因为直接内存的存在，所以我们断然不能把服务器的所有内存都分配给JVM。</strong></p>
<h3 id="OOM【OutOfMemoryError】总结"><a href="#OOM【OutOfMemoryError】总结" class="headerlink" title="OOM【OutOfMemoryError】总结"></a>OOM【OutOfMemoryError】总结</h3><p>在进行多线程开发访问的过程里面，所有的线程一定可以共享某一个线程执行体的堆内存空间（这个堆内存空间可以使用Runnable或者是Callable进行表述），同时方法上也可以实现线程操作的共享，正是因为方法上可以共享，所以在进行同步的时候往往就要在方法里面追加同步锁等相关定义。如果要进行内存区域的理解，那么首先就必须考虑程序代码之中可能出现的<strong>OOM</strong>问题。OOM分为两种情况：栈内存溢出【Stackoverflow】、堆内存溢出。<br><img src="https://img-blog.csdnimg.cn/20190622154807404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从开发角度来讲，最为常见的OOM肯定是堆内存溢出（产生了大量无用对象），栈内存发生数据溢出主要出现在<strong>递归操作</strong>上。正是因为所有的递归操作在执行的时候有可能产生栈溢出的问题，所以在项目编写之中往往都会建议使用while循环来代替递归操作。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java内存</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2018/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><blockquote>
<p>事务是对数据库的一系列操作，有明确的开始和结束标志，且要被完全执行，要么全部成功，要么全部失败。</p>
</blockquote>
<h1 id="为什么要使用事务？"><a href="#为什么要使用事务？" class="headerlink" title="为什么要使用事务？"></a>为什么要使用事务？</h1><blockquote>
<p>为了保证我们业务的完整性，因为我们的业务就是一个序列操作，具备这种要么全部成功，要么全部失败的特性。</p>
</blockquote>
<h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><p>事务具备如下四大特征【ACID】</p>
<ol>
<li>原子性（Atomicity）<br>事务最终状态只有两种，全部执行成功和全部不执行，事务中任何一项操作失败，都会导致整个事务失败。一旦失败所有操作都会被取消【回滚】，就像事务从来没有执行过一样。</li>
<li>一致性（Consistency）<br>事务执行前后，数据的完整性保持一致。</li>
<li>隔离性（Isolation）<br>多个事务并发执行时，多个事务之间互不干扰。即一个事务内部的操作及使用的数据，对其他并发事务是隔离的。</li>
<li>持久性（Durability）<br>事务结束后，对数据库所作的更改被永久保存下来了，即使发生系统故障或宕机，只要数据库能够恢复到被访问，那么一定能够被恢复到事务完成时的状态。</li>
</ol>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><blockquote>
<p>当数据库上有多个事务同时执行的时候，就可能出现脏读，不可重复读和幻读的问题，因此就有了“隔离级别”的概念。</p>
</blockquote>
<p>首先要知道，隔离得越严实，效率就越低。因此很多时候，要在这二者之间寻求一个平衡点。SQL标准的事务隔离级别包括如下几种。</p>
<ol>
<li>读未提交（read uncommitted）<br>一个事务还没提交，此时它所做的变更能被别的事务看到。此隔离级别会引发 <strong>脏读</strong> 的问题</li>
<li>读提交（read committed）<br>一个事务提交之后，它做的变更才会被其他事务看到。此隔离级别会引发 <strong>不可重复读</strong> 的问题。</li>
<li>可重复读（repeatable read）<br>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。此隔离级别下会引发 <strong>幻读</strong> 的问题。</li>
<li>串行化（serializable）<br>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后序访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ol>
<blockquote>
<p>Oracle数据库的默认隔离级别是 “读提交” 而 MySQL 的默认隔离级别是 “可重复读”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别一致，一定要记得修改隔离级别为“读提交”。</p>
</blockquote>
<h3 id="脏读，不可重复读和幻读都是什么？"><a href="#脏读，不可重复读和幻读都是什么？" class="headerlink" title="脏读，不可重复读和幻读都是什么？"></a>脏读，不可重复读和幻读都是什么？</h3><ol>
<li>脏读<br>脏读就是拿了别的事务还没提交的数据在此基础上做了别的业务处理。</li>
<li>不可重复读<br>在一个事务中，以相同的查询条件检索同一条数据，且当前事务没对此数据做任何修改，结果两次检索出的数据却不一致，说明有别的事务修改了此数据。</li>
<li>幻读<br>在一个事务中，以某个条件检索出了一批数据，假设检索出了五条数据集，批量修改此数据集，预期是返回修改五条记录。结果发现修改了六条，说明有别的事务插入了满足此检索条件的数据集。</li>
</ol>
<blockquote>
<p>这里对幻读的描述只是其中的一个场景，实际上不同事物 update，insert，delete 到同一批数据，都会出现幻读。原因在于“这些操作都是当前读的”。</p>
</blockquote>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><blockquote>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
</blockquote>
<p><strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong></p>
<ol>
<li>“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>
<li>“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是。</li>
<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。</li>
<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li>
</ol>
<h3 id="福利来啦"><a href="#福利来啦" class="headerlink" title="福利来啦"></a>福利来啦</h3><p>事务这一块的东西非常非常重要，楼主在大四出来实习的时候，基本去哪面试都有被问过，有幸读过一篇阅读量上万的事务总结，非常的受用，可是随着学习的积累，楼主发现那篇文章描述的知识点有一些错误之处【说明了学习时找对学习资源的重要性】，这个错误楼主不止在那篇文章中看到过，在别的地方也见到过，所以在这里做个记录，希望能帮到有缘人。</p>
<ul>
<li>情景再现<br>部分博客对幻读的描述是这样的：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。</li>
</ul>
<p>经楼主查证，其实这种幻读【BUG】，已经被 MVCC 机制修复了。只是比较老的书都已经发版了也没法改，新发行的书中基本都有提到这一点。为了增加说服力，以图做镇，以示清白！<br><img src="https://img-blog.csdnimg.cn/2020011316340260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NIRU5GVV9aS0s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
</search>
